# Research: Interactive Map Providers

**Feature Branch**: `012-interactive-map-providers`
**Date**: 2026-02-07

## Research Tasks

### RT-1: MapLibre GL JS Suitability and Integration Pattern

**Task**: Evaluate MapLibre GL JS as the open-source map provider for interactive mini-maps and full-screen tile map mode.

**Decision**: MapLibre GL JS is the primary provider. Install as npm dependency, load via dynamic `import()` for code-splitting.

**Rationale**: MapLibre GL JS is a community-maintained fork of Mapbox GL JS with an open-source BSD-3-Clause license. It provides GPU-accelerated vector tile rendering, built-in attribution controls, smooth fly-to animations, marker support, clustering, and style customization — all required by the spec. It has no API key requirement and works with any vector tile source. The library is ~200KB gzipped but Vite's dynamic import produces a separate chunk loaded only on demand, satisfying FR-013 (lazy loading).

**Alternatives considered**:

- Leaflet: Mature and lightweight, but primarily raster-tile based. Vector tile support requires plugins (protomaps-leaflet) that are less mature. Does not natively support smooth fly-to animations or the style customization needed for P3 branding. Rejected.
- Mapbox GL JS: Proprietary license (not open-source since v2.0). Requires Mapbox API token for all usage. Adds billable runtime dependency, violating the spirit of Principle VI more severely than MapLibre. Rejected.
- OpenLayers: Full-featured but significantly larger bundle size (~350KB gzipped). Over-engineered for this use case. Rejected.

### RT-2: Apple MapKit JS Integration Pattern

**Task**: Determine how to integrate Apple MapKit JS as the premium map provider.

**Decision**: Load Apple MapKit JS via dynamically-injected `<script>` tag with the Apple CDN URL. Authenticate using a JWT token stored in client config JSON.

**Rationale**: Apple MapKit JS is distributed exclusively via Apple's CDN (`https://cdn.apple-mapkit.com/mk/5.x.x/mapkit.core.js`) — it is not available as an npm package. The SDK authenticates via a JWT token passed to `mapkit.init()`. The token can be pre-generated with a long expiry (up to 10 years for development) and stored as a string in the client config JSON. This approach:

- Requires no runtime backend (token is static config, not generated on-the-fly)
- Provides 250,000 free map views/day (sufficient for demo and low-traffic deployments)
- Offers Apple's distinctive visual style for a premium demo experience

**Alternatives considered**:

- Server-side token generation: Apple recommends short-lived tokens generated by a backend for production. However, this violates Principle VI (zero runtime backend). For demo/low-traffic use, a long-lived pre-generated token is acceptable and explicitly scoped by the spec. Rejected for this project.
- Bundling the SDK: Not possible — Apple does not publish to npm. Must use CDN script injection.

### RT-3: Vector Tile Source Selection

**Task**: Determine the best free vector tile source for MapLibre GL JS.

**Decision**: OpenFreeMap as primary, MapTiler free tier as documented fallback.

**Rationale**: OpenFreeMap provides free vector tiles based on OpenStreetMap data with no API key, no registration, and no usage limits. It serves Mapbox Vector Tile (MVT) format compatible with MapLibre GL JS styles. The style URL is a simple HTTPS endpoint that can be overridden in client config for flexibility.

MapTiler's free tier (limited to 100,000 tile requests/month) serves as a documented fallback if OpenFreeMap has availability issues. MapTiler requires a free API key but provides higher SLA guarantees.

Vector tiles (not raster) are required because:

1. Sharp rendering at all zoom levels (no pixelation)
2. Style customization for light/dark theming (P3 requirement)
3. Client-side label rendering for localization potential
4. Smaller tile sizes for faster loading

**Alternatives considered**:

- OpenStreetMap raster tiles (tile.openstreetmap.org): Free, but raster tiles cannot be styled for light/dark theming or brand colors. Violates P3 branding requirements. Rejected.
- Self-hosted tiles: Requires server infrastructure, violating Principle VI. Rejected.
- Protomaps PMTiles: Interesting self-hosted alternative using static file hosting, but requires downloading a large (~70GB) planet file or regional extract. Overly complex for this use case. Rejected.

### RT-4: Lazy Loading Strategy

**Task**: Determine how to lazy-load map provider libraries without impacting initial page load.

**Decision**: MapLibre via Vite dynamic `import()` producing a separate chunk. Apple MapKit JS via dynamically-injected `<script>` tag with a Promise wrapper.

**Rationale**:

**MapLibre**: Installing as an npm dependency and using `const maplibregl = await import('maplibre-gl')` triggers Vite's code-splitting. The library and its CSS are placed in a separate chunk that is only downloaded when the import is executed. This is the standard Vite pattern for on-demand loading.

**Apple MapKit JS**: Since the SDK is CDN-only, we create a utility function that:

1. Checks if `window.mapkit` already exists (idempotent)
2. Creates a `<script>` element with the Apple CDN URL
3. Returns a Promise that resolves when the script's `onload` fires
4. Rejects on `onerror` (triggers fallback to MapLibre)

Both paths are triggered only when `MiniMap.show()` or `TileMap.init()` is called for the first time. The provider factory caches the loaded module/SDK reference so subsequent provider creations don't re-download.

**Alternatives considered**:

- Bundling MapLibre in the main chunk: Adds ~200KB to initial load, violating FR-013 and SC-008 (<50ms load increase). Rejected.
- Using `<link rel="preload">` for MapLibre chunk: Would download the chunk speculatively even if the user never opens a details panel. Violates the "on-demand only" principle. Rejected.
- Loading both providers at startup: Wastes bandwidth when only one provider is ever used per client. Rejected.

### RT-5: Provider Abstraction Pattern

**Task**: Determine the best pattern for abstracting multiple map providers behind a common interface.

**Decision**: TypeScript interface + factory function. No abstract base class.

**Rationale**: The `MapProvider` interface defines the contract that both MapLibre and Apple providers implement. A `createMapProvider(config)` factory function reads the `mapProvider` section of the client config and returns a Promise resolving to the appropriate provider instance. The factory handles:

1. Provider selection (default to MapLibre if not specified)
2. Lazy loading of the selected provider's library
3. Fallback from Apple to MapLibre on token/load failure
4. Logging warnings for fallback scenarios

Using a TypeScript interface (not abstract class) because:

- No shared implementation to inherit (each provider wraps a fundamentally different SDK)
- Interface-only approach is lighter and avoids unnecessary class hierarchy
- Matches the existing `MapComponent` interface pattern in `app.ts`

The `TileMapProvider` interface extends `MapProvider` with additional methods for clustering, multi-marker placement, and marker click handling — needed only by the full-screen tile map mode.

**Alternatives considered**:

- Abstract base class with template methods: Would add an inheritance layer with no shared implementation to factor out. Both providers have completely different initialization, marker, and animation APIs. Rejected.
- Single monolithic provider with internal if/else: Would violate single responsibility and make the code harder to test. Rejected.
- Plugin/registry pattern: Over-engineered for two providers. The factory function is sufficient and simpler. Rejected.

### RT-6: Constitution Principle VI Violation Justification

**Task**: Analyze the conflict between the interactive map feature and Constitution Principle VI ("Zero Runtime Backend").

**Decision**: Proceed with justified violation. Document in Complexity Tracking.

**Rationale**: Principle VI prohibits "embedded maps requiring API keys" and "external data fetches at runtime." This feature introduces both (tile requests and Apple Maps JWT). However:

1. **The violation is proportional to the value delivered**: The spec's core purpose is replacing a static iframe with an interactive, explorable map. Interactivity requires dynamic tile loading — there is no way to deliver pan/zoom/fly-to with static assets.

2. **The default path (MapLibre + OpenFreeMap) has zero API keys and zero cost**: This satisfies the economic intent of Principle VI ("eliminates runtime costs"). Tile requests are analogous to loading CDN images — the data (office coordinates) remains build-time immutable; tiles are presentation.

3. **Apple Maps is opt-in for demos only**: The JWT token is pre-generated static config, not a runtime API call. The 250,000 free daily views far exceed demo usage.

4. **Mitigation measures preserve the principle's intent**: Lazy loading (no requests until needed), pinned library versions (CDN with integrity hash), graceful degradation (fallback message on tile failure), and zero-cost default path.

5. **The existing Google Maps iframe already violates Principle VI**: The current implementation loads an entire Google Maps embed via iframe, which makes uncontrolled runtime requests. This feature actually reduces the violation's severity by using a controlled, self-hosted-capable library.

### RT-7: Expand Overlay Implementation Strategy

**Task**: Determine how to implement the mini-map expand/collapse functionality.

**Decision**: DOM reparenting of the map provider's canvas element between the inline container and a full-screen overlay.

**Rationale**: When the user clicks the expand button on the mini-map:

1. A full-screen overlay element is created (or shown if already exists)
2. The map provider's root element (MapLibre canvas or Apple MapKit container) is moved from the inline `.mini-map-container` to the overlay container via `overlay.appendChild(mapElement)`
3. `provider.resize()` is called to trigger the map to recalculate its viewport for the larger container
4. The overlay includes a close button, handles ESC key, and click-outside dismiss
5. On close: the map element is moved back to the inline container, `provider.resize()` called again

This preserves:

- Map state (current pan/zoom position) — FR-018
- Loaded tiles (no re-fetch)
- Marker position and styling

**Alternatives considered**:

- Creating a second map instance in the overlay: Requires re-downloading tiles, loses current viewport state, and doubles memory usage. Rejected.
- CSS-only fullscreen (transform: scale): Would not allow the map to render at full resolution. Tiles would appear blurry. Rejected.
- Fullscreen API (`element.requestFullscreen()`): Browser-native but inconsistent UX across browsers and doesn't allow custom overlay styling. Rejected.

### RT-8: Marker Clustering for Tile Map Mode

**Task**: Determine the approach for marker clustering in the full-screen tile map mode.

**Decision**: Use MapLibre GL JS's built-in GeoJSON source with cluster properties.

**Rationale**: MapLibre natively supports marker clustering via GeoJSON sources with `cluster: true`. This provides:

- Automatic grouping of nearby markers at low zoom levels
- Smooth cluster expansion on zoom
- Customizable cluster circle styling (count label, brand-colored circles)
- Click-to-zoom on clusters
- No additional library needed

The cluster layer uses three paint properties: cluster circle fill (brand color with opacity), cluster count text, and unclustered point markers (individual office markers).

**Alternatives considered**:

- Supercluster library: Standalone clustering library. MapLibre already uses Supercluster internally for its GeoJSON clustering. Adding it separately would be redundant. Rejected.
- Custom DOM-based clustering: Would require manual calculation of screen positions and cluster grouping. MapLibre does this natively with better performance (GPU-accelerated). Rejected.

### RT-9: Existing Codebase Integration Points

**Task**: Identify all code locations that need modification and understand the integration surface.

**Findings**:

1. **details-panel.js lines 221-238**: Google Maps iframe embed. Replace with mini-map container div. The `showOffice()` method needs a mini-map lifecycle hook.

2. **office-modal.js**: Currently has NO embedded map (just a "Get Directions" link). Add mini-map container between contact info and footer.

3. **app.ts `initMap()`**: Currently branches on `this.use3D` boolean. Needs to become a three-way switch on `this.mapMode`.

4. **app.ts `toggleMapMode()`**: Currently flips `use3D` boolean. Replace with `switchMapMode(mode)` that accepts the target mode.

5. **app.ts `MapComponent` interface**: Already defines the contract (selectRegion, selectOffice, reset, updateMarkerStates, dispose). TileMap implements this directly.

6. **client-config.schema.ts `BrandThemeSchema`**: Add optional `mapProvider` field with provider type, tile URL, Apple token, and default zoom.

7. **app.css `.mini-map-container` / `.mini-map-embed`**: Existing styles for the iframe. Repurpose container, remove embed class.

8. **index.html `#map-toggle`**: Button element to replace with three-way selector group.
